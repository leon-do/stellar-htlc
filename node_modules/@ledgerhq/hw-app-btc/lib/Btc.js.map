{"version":3,"sources":["../src/Btc.js"],"names":["MAX_SCRIPT_BLOCK","DEFAULT_VERSION","DEFAULT_LOCKTIME","DEFAULT_SEQUENCE","SIGHASH_ALL","OP_DUP","OP_HASH160","HASH_SIZE","OP_EQUALVERIFY","OP_CHECKSIG","Btc","transport","scrambleKey","decorateAppAPIMethods","buffer","update","digest","path","verify","segwit","paths","p1","p2","Buffer","alloc","length","forEach","element","index","writeUInt32BE","send","then","publicKeyLength","response","addressLength","publicKey","slice","toString","bitcoinAddress","chainCode","getWalletPublicKey_private","transactionData","indexLookup","data","firstRound","prefix","concat","trustedInput","transaction","additionals","inputs","outputs","locktime","Error","isDecred","includes","processScriptBlocks","script","sequence","scriptBlocks","offset","blockSize","push","getTrustedInputRaw","scriptBlock","processWholeScriptBlock","processInputs","input","prevout","from","createVarint","processOutputs","output","amount","finalData","version","timestamp","sha","serializeTransaction","hash","writeUInt32LE","newTransaction","bip143","overwinter","nVersionGroupId","startUntrustedHashTransactionInputRaw","i","value","outputScript","lockTime","sigHashType","expiryHeight","pathsBuffer","lockTimeBuffer","result","messageHex","message","toSend","maxChunkSize","chunkSize","writeUInt16BE","copy","v","r","s","associatedKeysets","changePath","outputScriptHex","initialTimestamp","hasTimestamp","undefined","startTime","Date","now","sapling","useBip143","nullScript","nullPrevout","defaultVersion","trustedInputs","regularOutputs","signatures","publicKeys","firstRun","resuming","targetTransaction","getTrustedInputCall","getTrustedInputBIP143","bind","getTrustedInput","nExpiryHeight","extraData","compressPublicKey","Math","floor","startUntrustedHashTransactionInput","provideOutputFullChangePath","hashOutputFull","signTransaction","hashPublicKey","pseudoTX","Object","assign","pseudoTrustedInputs","signature","witness","signatureSize","keySize","tmpScriptData","decredWitness","inputIndex","transactionVersion","prefixBuffer","transactionHex","isSegwitSupported","hasExtraData","equals","varint","getVarint","numberInputs","numberOutputs","witnessScript","outputBuffer","skipWitness","inputBuffer","useWitness","serializeTransactionOutputs","console","log"],"mappings":"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","file":"Btc.js","sourcesContent":["//@flow\n\n// TODO future refactoring\n// - drop utils.js & refactoring with async/await style\n// - try to avoid every place we do hex<>Buffer conversion. also accept Buffer as func parameters (could accept both a string or a Buffer in the API)\n// - there are redundant code across apps (see Eth vs Btc). we might want to factorize it somewhere. also each app apdu call should be abstracted it out as an api\nimport { foreach, doIf, asyncWhile, splitPath, eachSeries } from \"./utils\";\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport createHash from \"create-hash\";\n\nconst MAX_SCRIPT_BLOCK = 50;\nconst DEFAULT_VERSION = 1;\nconst DEFAULT_LOCKTIME = 0;\nconst DEFAULT_SEQUENCE = 0xffffffff;\nconst SIGHASH_ALL = 1;\nconst OP_DUP = 0x76;\nconst OP_HASH160 = 0xa9;\nconst HASH_SIZE = 0x14;\nconst OP_EQUALVERIFY = 0x88;\nconst OP_CHECKSIG = 0xac;\n/**\n * Bitcoin API.\n *\n * @example\n * import Btc from \"@ledgerhq/hw-app-btc\";\n * const btc = new Btc(transport)\n */\nexport default class Btc {\n  transport: Transport<*>;\n\n  constructor(transport: Transport<*>, scrambleKey: string = \"BTC\") {\n    this.transport = transport;\n    transport.decorateAppAPIMethods(\n      this,\n      [\n        \"getWalletPublicKey\",\n        \"signP2SHTransaction\",\n        \"signMessageNew\",\n        \"createPaymentTransactionNew\"\n      ],\n      scrambleKey\n    );\n  }\n\n  hashPublicKey(buffer: Buffer) {\n    return createHash(\"rmd160\")\n      .update(\n        createHash(\"sha256\")\n          .update(buffer)\n          .digest()\n      )\n      .digest();\n  }\n\n  getWalletPublicKey_private(\n    path: string,\n    verify: boolean,\n    segwit: boolean\n  ): Promise<{\n    publicKey: string,\n    bitcoinAddress: string,\n    chainCode: string\n  }> {\n    const paths = splitPath(path);\n    var p1 = 0x00;\n    var p2 = 0x00;\n    if (verify === true) {\n      p1 = 0x01;\n    }\n    if (segwit == true) {\n      p2 = 0x01;\n    }\n    const buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport.send(0xe0, 0x40, p1, p2, buffer).then(response => {\n      const publicKeyLength = response[0];\n      const addressLength = response[1 + publicKeyLength];\n      const publicKey = response.slice(1, 1 + publicKeyLength).toString(\"hex\");\n      const bitcoinAddress = response\n        .slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength)\n        .toString(\"ascii\");\n      const chainCode = response\n        .slice(\n          1 + publicKeyLength + 1 + addressLength,\n          1 + publicKeyLength + 1 + addressLength + 32\n        )\n        .toString(\"hex\");\n      return { publicKey, bitcoinAddress, chainCode };\n    });\n  }\n\n  /**\n   * @param path a BIP 32 path\n   * @param segwit use segwit\n   * @example\n   * btc.getWalletPublicKey(\"44'/0'/0'/0\").then(o => o.bitcoinAddress)\n   */\n  getWalletPublicKey(\n    path: string,\n    verify?: boolean = false,\n    segwit?: boolean = false\n  ): Promise<{\n    publicKey: string,\n    bitcoinAddress: string,\n    chainCode: string\n  }> {\n    return this.getWalletPublicKey_private(path, verify, segwit);\n  }\n\n  getTrustedInputRaw(\n    transactionData: Buffer,\n    indexLookup: ?number\n  ): Promise<string> {\n    let data;\n    let firstRound = false;\n    if (typeof indexLookup === \"number\") {\n      firstRound = true;\n      const prefix = Buffer.alloc(4);\n      prefix.writeUInt32BE(indexLookup, 0);\n      data = Buffer.concat(\n        [prefix, transactionData],\n        transactionData.length + 4\n      );\n    } else {\n      data = transactionData;\n    }\n    return this.transport\n      .send(0xe0, 0x42, firstRound ? 0x00 : 0x80, 0x00, data)\n      .then(trustedInput =>\n        trustedInput.slice(0, trustedInput.length - 2).toString(\"hex\")\n      );\n  }\n\n  getTrustedInput(\n    indexLookup: number,\n    transaction: Transaction,\n    additionals: Array<string> = []\n  ): Promise<string> {\n    const { inputs, outputs, locktime } = transaction;\n    if (!outputs || !locktime) {\n      throw new Error(\"getTrustedInput: locktime & outputs is expected\");\n    }\n    const isDecred = additionals.includes(\"decred\");\n    const processScriptBlocks = (script, sequence) => {\n      const scriptBlocks = [];\n      let offset = 0;\n      while (offset !== script.length) {\n        let blockSize =\n          script.length - offset > MAX_SCRIPT_BLOCK\n            ? MAX_SCRIPT_BLOCK\n            : script.length - offset;\n        if (offset + blockSize !== script.length) {\n          scriptBlocks.push(script.slice(offset, offset + blockSize));\n        } else {\n          scriptBlocks.push(\n            Buffer.concat([script.slice(offset, offset + blockSize), sequence])\n          );\n        }\n        offset += blockSize;\n      }\n\n      // Handle case when no script length: we still want to pass the sequence\n      // relatable: https://github.com/LedgerHQ/ledger-live-desktop/issues/1386\n      if (script.length === 0) {\n        scriptBlocks.push(sequence);\n      }\n\n      return eachSeries(scriptBlocks, scriptBlock =>\n        this.getTrustedInputRaw(scriptBlock)\n      );\n    };\n\n    const processWholeScriptBlock = (script, sequence) =>\n      this.getTrustedInputRaw(Buffer.concat([script, sequence]));\n\n    const processInputs = () => {\n      return eachSeries(inputs, input => {\n        const data = Buffer.concat([\n          input.prevout,\n          isDecred ? Buffer.from([0x00]) : Buffer.alloc(0), //tree\n          this.createVarint(input.script.length)\n        ]);\n        return this.getTrustedInputRaw(data).then(() => {\n          // iteration (eachSeries) ended\n          // TODO notify progress\n          // deferred.notify(\"input\");\n          return isDecred\n            ? processWholeScriptBlock(input.script, input.sequence)\n            : processScriptBlocks(input.script, input.sequence);\n        });\n      }).then(() => {\n        const data = this.createVarint(outputs.length);\n        return this.getTrustedInputRaw(data);\n      });\n    };\n\n    const processOutputs = () =>\n      eachSeries(outputs, output => {\n        let data = output.amount;\n        data = Buffer.concat([\n          data,\n          isDecred ? Buffer.from([0x00, 0x00]) : Buffer.alloc(0), //Version script\n          this.createVarint(output.script.length),\n          output.script\n        ]);\n        return this.getTrustedInputRaw(data).then(() => {\n          // iteration (eachSeries) ended\n          // TODO notify progress\n          // deferred.notify(\"output\");\n        });\n      }).then(() => {\n        //Add expiry height for decred\n        const finalData = isDecred\n          ? Buffer.concat([locktime, Buffer.from([0x00, 0x00, 0x00, 0x00])])\n          : locktime;\n        return this.getTrustedInputRaw(finalData);\n      });\n\n    const data = Buffer.concat([\n      transaction.version,\n      transaction.timestamp || Buffer.alloc(0),\n      this.createVarint(inputs.length)\n    ]);\n    return this.getTrustedInputRaw(data, indexLookup)\n      .then(processInputs)\n      .then(processOutputs);\n  }\n\n  async getTrustedInputBIP143(\n    indexLookup: number,\n    transaction: Transaction,\n    additionals: Array<string> = []\n  ) {\n    if (!transaction) {\n      throw new Error(\"getTrustedInputBIP143: missing tx\");\n    }\n    const isDecred = additionals.includes(\"decred\");\n    if (isDecred) {\n      throw new Error(\"Decred does not implement BIP143\");\n    }\n    let sha = createHash(\"sha256\");\n    sha.update(this.serializeTransaction(transaction, true));\n    let hash = sha.digest();\n    sha = createHash(\"sha256\");\n    sha.update(hash);\n    hash = sha.digest();\n    const data = Buffer.alloc(4);\n    data.writeUInt32LE(indexLookup, 0);\n    const { outputs, locktime } = transaction;\n    if (!outputs || !locktime) {\n      throw new Error(\"getTrustedInputBIP143: locktime & outputs is expected\");\n    }\n    if (!outputs[indexLookup]) {\n      throw new Error(\"getTrustedInputBIP143: wrong index\");\n    }\n    hash = Buffer.concat([hash, data, outputs[indexLookup].amount]);\n    return await hash.toString(\"hex\");\n  }\n\n  getVarint(data: Buffer, offset: number): [number, number] {\n    if (data[offset] < 0xfd) {\n      return [data[offset], 1];\n    }\n    if (data[offset] === 0xfd) {\n      return [(data[offset + 2] << 8) + data[offset + 1], 3];\n    }\n    if (data[offset] === 0xfe) {\n      return [\n        (data[offset + 4] << 24) +\n          (data[offset + 3] << 16) +\n          (data[offset + 2] << 8) +\n          data[offset + 1],\n        5\n      ];\n    }\n\n    throw new Error(\"getVarint called with unexpected parameters\");\n  }\n\n  startUntrustedHashTransactionInputRaw(\n    newTransaction: boolean,\n    firstRound: boolean,\n    transactionData: Buffer,\n    bip143?: boolean = false,\n    overwinter?: boolean = false,\n    additionals: Array<string> = []\n  ) {\n    const p2 = bip143\n      ? additionals.includes(\"sapling\")\n        ? 0x05\n        : overwinter\n          ? 0x04\n          : 0x02\n      : 0x00;\n    return this.transport.send(\n      0xe0,\n      0x44,\n      firstRound ? 0x00 : 0x80,\n      newTransaction ? p2 : 0x80,\n      transactionData\n    );\n  }\n\n  startUntrustedHashTransactionInput(\n    newTransaction: boolean,\n    transaction: Transaction,\n    inputs: Array<{ trustedInput: boolean, value: Buffer }>,\n    bip143?: boolean = false,\n    overwinter?: boolean = false,\n    additionals: Array<string> = []\n  ) {\n    let data = Buffer.concat([\n      transaction.version,\n      transaction.timestamp || Buffer.alloc(0),\n      transaction.nVersionGroupId || Buffer.alloc(0),\n      this.createVarint(transaction.inputs.length)\n    ]);\n    return this.startUntrustedHashTransactionInputRaw(\n      newTransaction,\n      true,\n      data,\n      bip143,\n      overwinter,\n      additionals\n    ).then(() => {\n      let i = 0;\n      const isDecred = additionals.includes(\"decred\");\n      return eachSeries(transaction.inputs, input => {\n        let prefix;\n        if (bip143) {\n          prefix = Buffer.from([0x02]);\n        } else {\n          if (inputs[i].trustedInput) {\n            prefix = Buffer.from([0x01, inputs[i].value.length]);\n          } else {\n            prefix = Buffer.from([0x00]);\n          }\n        }\n        data = Buffer.concat([\n          prefix,\n          inputs[i].value,\n          isDecred ? Buffer.from([0x00]) : Buffer.alloc(0),\n          this.createVarint(input.script.length)\n        ]);\n        return this.startUntrustedHashTransactionInputRaw(\n          newTransaction,\n          false,\n          data,\n          bip143,\n          overwinter,\n          additionals\n        ).then(() => {\n          let scriptBlocks = [];\n          let offset = 0;\n          if (input.script.length === 0) {\n            scriptBlocks.push(input.sequence);\n          } else {\n            while (offset !== input.script.length) {\n              let blockSize =\n                input.script.length - offset > MAX_SCRIPT_BLOCK\n                  ? MAX_SCRIPT_BLOCK\n                  : input.script.length - offset;\n              if (offset + blockSize !== input.script.length) {\n                scriptBlocks.push(\n                  input.script.slice(offset, offset + blockSize)\n                );\n              } else {\n                scriptBlocks.push(\n                  Buffer.concat([\n                    input.script.slice(offset, offset + blockSize),\n                    input.sequence\n                  ])\n                );\n              }\n              offset += blockSize;\n            }\n          }\n          return eachSeries(scriptBlocks, scriptBlock => {\n            return this.startUntrustedHashTransactionInputRaw(\n              newTransaction,\n              false,\n              scriptBlock,\n              bip143,\n              overwinter,\n              additionals\n            );\n          }).then(() => {\n            i++;\n          });\n        });\n      });\n    });\n  }\n\n  provideOutputFullChangePath(path: string): Promise<string> {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport.send(0xe0, 0x4a, 0xff, 0x00, buffer);\n  }\n\n  hashOutputFull(\n    outputScript: Buffer,\n    additionals: Array<string> = []\n  ): Promise<*> {\n    let offset = 0;\n    let p1 = 0x80;\n    const isDecred = additionals.includes(\"decred\");\n    ///WARNING: Decred works only with one call (without chunking)\n    //TODO: test without this for Decred\n    if (isDecred) {\n      return this.transport.send(0xe0, 0x4a, p1, 0x00, outputScript);\n    }\n    return asyncWhile(\n      () => offset < outputScript.length,\n      () => {\n        let blockSize =\n          offset + MAX_SCRIPT_BLOCK >= outputScript.length\n            ? outputScript.length - offset\n            : MAX_SCRIPT_BLOCK;\n        let p1 = offset + blockSize === outputScript.length ? 0x80 : 0x00;\n        let data = outputScript.slice(offset, offset + blockSize);\n\n        return this.transport.send(0xe0, 0x4a, p1, 0x00, data).then(() => {\n          offset += blockSize;\n        });\n      }\n    );\n  }\n\n  signTransaction(\n    path: string,\n    lockTime?: number = DEFAULT_LOCKTIME,\n    sigHashType?: number = SIGHASH_ALL,\n    expiryHeight?: Buffer,\n    additionals: Array<string> = []\n  ): Promise<Buffer> {\n    const isDecred = additionals.includes(\"decred\");\n    const paths = splitPath(path);\n    let offset = 0;\n    const pathsBuffer = Buffer.alloc(paths.length * 4);\n    paths.forEach(element => {\n      pathsBuffer.writeUInt32BE(element, offset);\n      offset += 4;\n    });\n    const lockTimeBuffer = Buffer.alloc(4);\n    lockTimeBuffer.writeUInt32BE(lockTime, 0);\n    let buffer = isDecred\n      ? Buffer.concat([\n          Buffer.from([paths.length]),\n          pathsBuffer,\n          lockTimeBuffer,\n          expiryHeight || Buffer.from([0x00, 0x00, 0x00, 0x00]),\n          Buffer.from([sigHashType])\n        ])\n      : Buffer.concat([\n          Buffer.from([paths.length]),\n          pathsBuffer,\n          Buffer.from([0x00]),\n          lockTimeBuffer,\n          Buffer.from([sigHashType])\n        ]);\n    if (expiryHeight && !isDecred) {\n      buffer = Buffer.concat([buffer, expiryHeight]);\n    }\n    return this.transport.send(0xe0, 0x48, 0x00, 0x00, buffer).then(result => {\n      if (result.length > 0) {\n        result[0] = 0x30;\n        return result.slice(0, result.length - 2);\n      }\n      return result;\n    });\n  }\n\n  /**\n   * You can sign a message according to the Bitcoin Signature format and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n   * @example\n   btc.signMessageNew_async(\"44'/60'/0'/0'/0\", Buffer.from(\"test\").toString(\"hex\")).then(function(result) {\n     var v = result['v'] + 27 + 4;\n     var signature = Buffer.from(v.toString(16) + result['r'] + result['s'], 'hex').toString('base64');\n     console.log(\"Signature : \" + signature);\n   }).catch(function(ex) {console.log(ex);});\n   */\n  signMessageNew(\n    path: string,\n    messageHex: string\n  ): Promise<{ v: number, r: string, s: string }> {\n    const paths = splitPath(path);\n    const message = new Buffer(messageHex, \"hex\");\n    let offset = 0;\n    const toSend = [];\n    while (offset !== message.length) {\n      let maxChunkSize =\n        offset === 0\n          ? MAX_SCRIPT_BLOCK - 1 - paths.length * 4 - 4\n          : MAX_SCRIPT_BLOCK;\n      let chunkSize =\n        offset + maxChunkSize > message.length\n          ? message.length - offset\n          : maxChunkSize;\n      const buffer = new Buffer(\n        offset === 0 ? 1 + paths.length * 4 + 2 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        buffer.writeUInt16BE(message.length, 1 + 4 * paths.length);\n        message.copy(\n          buffer,\n          1 + 4 * paths.length + 2,\n          offset,\n          offset + chunkSize\n        );\n      } else {\n        message.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport.send(0xe0, 0x4e, 0x00, i === 0 ? 0x01 : 0x80, data)\n    ).then(() => {\n      return this.transport\n        .send(0xe0, 0x4e, 0x80, 0x00, Buffer.from([0x00]))\n        .then(response => {\n          const v = response[0] - 0x30;\n          let r = response.slice(4, 4 + response[3]);\n          if (r[0] === 0) {\n            r = r.slice(1);\n          }\n          r = r.toString(\"hex\");\n          let offset = 4 + response[3] + 2;\n          let s = response.slice(offset, offset + response[offset - 1]);\n          if (s[0] === 0) {\n            s = s.slice(1);\n          }\n          s = s.toString(\"hex\");\n          return { v, r, s };\n        });\n    });\n  }\n\n  /**\n   * To sign a transaction involving standard (P2PKH) inputs, call createPaymentTransactionNew with the following parameters\n   * @param inputs is an array of [ transaction, output_index, optional redeem script, optional sequence ] where\n   *\n   * * transaction is the previously computed transaction object for this UTXO\n   * * output_index is the output in the transaction used as input for this UTXO (counting from 0)\n   * * redeem script is the optional redeem script to use when consuming a Segregated Witness input\n   * * sequence is the sequence number to use for this input (when using RBF), or non present\n   * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO\n   * @param changePath is an optional BIP 32 path pointing to the path to the public key used to compute the change address\n   * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign\n   * @param lockTime is the optional lockTime of the transaction to sign, or default (0)\n   * @param sigHashType is the hash type of the transaction to sign, or default (all)\n   * @param segwit is an optional boolean indicating wether to use segwit or not\n   * @param initialTimestamp is an optional timestamp of the function call to use for coins that necessitate timestamps only, (not the one that the tx will include)\n   * @param additionals list of additionnal options\n   * - \"abc\" for bch\n   * - \"gold\" for btg\n   * - \"bipxxx\" for using BIPxxx\n   * - \"sapling\" to indicate a zec transaction is supporting sapling (to be set over block 419200)\n   * @param expiryHeight is an optional Buffer for zec overwinter / sapling Txs\n   * @return the signed transaction ready to be broadcast\n   * @example\nbtc.createPaymentTransactionNew(\n   [ [tx1, 1] ],\n   [\"0'/0/0\"],\n   undefined,\n   \"01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac\"\n ).then(res => ...);\n   */\n  createPaymentTransactionNew(\n    inputs: Array<[Transaction, number, ?string, ?number]>,\n    associatedKeysets: string[],\n    changePath?: string,\n    outputScriptHex: string,\n    lockTime?: number = DEFAULT_LOCKTIME,\n    sigHashType?: number = SIGHASH_ALL,\n    segwit?: boolean = false,\n    initialTimestamp?: number,\n    additionals: Array<string> = [],\n    expiryHeight?: Buffer\n  ) {\n    const isDecred = additionals.includes(\"decred\");\n    const hasTimestamp = initialTimestamp !== undefined;\n    let startTime = Date.now();\n    const sapling = additionals.includes(\"sapling\");\n    let useBip143 =\n      segwit ||\n      (!!additionals &&\n        (additionals.includes(\"abc\") ||\n          additionals.includes(\"gold\") ||\n          additionals.includes(\"bip143\"))) ||\n      (!!expiryHeight && !isDecred);\n    // Inputs are provided as arrays of [transaction, output_index, optional redeem script, optional sequence]\n    // associatedKeysets are provided as arrays of [path]\n    const nullScript = Buffer.alloc(0);\n    const nullPrevout = Buffer.alloc(0);\n    const defaultVersion = Buffer.alloc(4);\n    !!expiryHeight && !isDecred\n      ? defaultVersion.writeUInt32LE(sapling ? 0x80000004 : 0x80000003, 0)\n      : defaultVersion.writeUInt32LE(1, 0);\n    const trustedInputs: Array<*> = [];\n    const regularOutputs: Array<TransactionOutput> = [];\n    const signatures = [];\n    const publicKeys = [];\n    let firstRun = true;\n    const resuming = false;\n    const targetTransaction: Transaction = {\n      inputs: [],\n      version: defaultVersion,\n      timestamp: Buffer.alloc(0)\n    };\n    const getTrustedInputCall = useBip143\n      ? this.getTrustedInputBIP143.bind(this)\n      : this.getTrustedInput.bind(this);\n    const outputScript = Buffer.from(outputScriptHex, \"hex\");\n\n    return foreach(inputs, input => {\n      return doIf(!resuming, () => {\n        return getTrustedInputCall(input[1], input[0], additionals).then(\n          trustedInput => {\n            let sequence = Buffer.alloc(4);\n            sequence.writeUInt32LE(\n              input.length >= 4 && typeof input[3] === \"number\"\n                ? input[3]\n                : DEFAULT_SEQUENCE,\n              0\n            );\n            trustedInputs.push({\n              trustedInput: true,\n              value: Buffer.from(trustedInput, \"hex\"),\n              sequence\n            });\n          }\n        );\n      })\n        .then(() => {\n          const { outputs } = input[0];\n          const index = input[1];\n          if (outputs && index <= outputs.length - 1) {\n            regularOutputs.push(outputs[index]);\n          }\n        })\n        .then(() => {\n          if (!!expiryHeight && !isDecred) {\n            targetTransaction.nVersionGroupId = Buffer.from(\n              sapling ? [0x85, 0x20, 0x2f, 0x89] : [0x70, 0x82, 0xc4, 0x03]\n            );\n            targetTransaction.nExpiryHeight = expiryHeight;\n            // For sapling : valueBalance (8), nShieldedSpend (1), nShieldedOutput (1), nJoinSplit (1)\n            // Overwinter : use nJoinSplit (1)\n            targetTransaction.extraData = Buffer.from(\n              sapling\n                ? [\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00\n                  ]\n                : [0x00]\n            );\n          } else if (isDecred) {\n            targetTransaction.nExpiryHeight = expiryHeight;\n          }\n        });\n    })\n      .then(() => {\n        for (let i = 0; i < inputs.length; i++) {\n          let sequence = Buffer.alloc(4);\n          sequence.writeUInt32LE(\n            inputs[i].length >= 4 && typeof inputs[i][3] === \"number\"\n              ? inputs[i][3]\n              : DEFAULT_SEQUENCE,\n            0\n          );\n          targetTransaction.inputs.push({\n            script: nullScript,\n            prevout: nullPrevout,\n            sequence\n          });\n        }\n      })\n      .then(() =>\n        doIf(!resuming, () =>\n          // Collect public keys\n          foreach(inputs, (input, i) =>\n            this.getWalletPublicKey_private(associatedKeysets[i], false, false)\n          ).then(result => {\n            for (let index = 0; index < result.length; index++) {\n              publicKeys.push(\n                this.compressPublicKey(\n                  Buffer.from(result[index].publicKey, \"hex\")\n                )\n              );\n            }\n          })\n        )\n      )\n      .then(() => {\n        if (hasTimestamp) {\n          targetTransaction.timestamp = Buffer.alloc(4);\n          targetTransaction.timestamp.writeUInt32LE(\n            Math.floor(initialTimestamp + (Date.now() - startTime) / 1000),\n            0\n          );\n        }\n      })\n      .then(() =>\n        doIf(useBip143, () =>\n          // Do the first run with all inputs\n          this.startUntrustedHashTransactionInput(\n            true,\n            targetTransaction,\n            trustedInputs,\n            true,\n            !!expiryHeight,\n            additionals\n          ).then(() =>\n            doIf(!resuming && typeof changePath != \"undefined\", () => {\n              // $FlowFixMe\n              return this.provideOutputFullChangePath(changePath);\n            }).then(() => this.hashOutputFull(outputScript))\n          )\n        )\n      )\n      .then(() =>\n        doIf(!!expiryHeight && !isDecred, () =>\n          this.signTransaction(\"\", undefined, SIGHASH_ALL, expiryHeight)\n        )\n      )\n      .then(() =>\n        // Do the second run with the individual transaction\n        foreach(inputs, (input, i) => {\n          let script =\n            inputs[i].length >= 3 && typeof inputs[i][2] === \"string\"\n              ? Buffer.from(inputs[i][2], \"hex\")\n              : !segwit\n                ? regularOutputs[i].script\n                : Buffer.concat([\n                    Buffer.from([OP_DUP, OP_HASH160, HASH_SIZE]),\n                    this.hashPublicKey(publicKeys[i]),\n                    Buffer.from([OP_EQUALVERIFY, OP_CHECKSIG])\n                  ]);\n          let pseudoTX = Object.assign({}, targetTransaction);\n          let pseudoTrustedInputs = useBip143\n            ? [trustedInputs[i]]\n            : trustedInputs;\n          if (useBip143) {\n            pseudoTX.inputs = [{ ...pseudoTX.inputs[i], script }];\n          } else {\n            pseudoTX.inputs[i].script = script;\n          }\n          return this.startUntrustedHashTransactionInput(\n            !useBip143 && firstRun,\n            pseudoTX,\n            pseudoTrustedInputs,\n            useBip143,\n            !!expiryHeight && !isDecred,\n            additionals\n          )\n            .then(() =>\n              doIf(!useBip143, () =>\n                doIf(!resuming && typeof changePath != \"undefined\", () => {\n                  // $FlowFixMe\n                  return this.provideOutputFullChangePath(changePath);\n                }).then(() => this.hashOutputFull(outputScript, additionals))\n              )\n            )\n            .then(() => {\n              return this.signTransaction(\n                associatedKeysets[i],\n                lockTime,\n                sigHashType,\n                expiryHeight,\n                additionals\n              );\n            })\n            .then(signature => {\n              signatures.push(signature);\n              targetTransaction.inputs[i].script = nullScript;\n              if (firstRun) {\n                firstRun = false;\n              }\n            });\n        })\n      )\n      .then(() => {\n        // Populate the final input scripts\n        for (let i = 0; i < inputs.length; i++) {\n          if (segwit) {\n            targetTransaction.witness = Buffer.alloc(0);\n            targetTransaction.inputs[i].script = Buffer.concat([\n              Buffer.from(\"160014\", \"hex\"),\n              this.hashPublicKey(publicKeys[i])\n            ]);\n          } else {\n            const signatureSize = Buffer.alloc(1);\n            const keySize = Buffer.alloc(1);\n            signatureSize[0] = signatures[i].length;\n            keySize[0] = publicKeys[i].length;\n            targetTransaction.inputs[i].script = Buffer.concat([\n              signatureSize,\n              signatures[i],\n              keySize,\n              publicKeys[i]\n            ]);\n          }\n          let offset = useBip143 ? 0 : 4;\n          targetTransaction.inputs[i].prevout = trustedInputs[i].value.slice(\n            offset,\n            offset + 0x24\n          );\n        }\n\n        const lockTimeBuffer = Buffer.alloc(4);\n        lockTimeBuffer.writeUInt32LE(lockTime, 0);\n\n        var result = Buffer.concat([\n          this.serializeTransaction(\n            targetTransaction,\n            false,\n            targetTransaction.timestamp,\n            additionals\n          ),\n          outputScript\n        ]);\n\n        if (segwit && !isDecred) {\n          var witness = Buffer.alloc(0);\n          for (var i = 0; i < inputs.length; i++) {\n            var tmpScriptData = Buffer.concat([\n              Buffer.from(\"02\", \"hex\"),\n              Buffer.from([signatures[i].length]),\n              signatures[i],\n              Buffer.from([publicKeys[i].length]),\n              publicKeys[i]\n            ]);\n            witness = Buffer.concat([witness, tmpScriptData]);\n          }\n          result = Buffer.concat([result, witness]);\n        }\n        if (expiryHeight) {\n          result = Buffer.concat([\n            result,\n            targetTransaction.nExpiryHeight || Buffer.alloc(0),\n            targetTransaction.extraData || Buffer.alloc(0)\n          ]);\n        }\n\n        result = Buffer.concat([result, lockTimeBuffer]);\n\n        if (isDecred) {\n          let decredWitness = Buffer.from([targetTransaction.inputs.length]);\n          inputs.forEach((input, inputIndex) => {\n            decredWitness = Buffer.concat([\n              decredWitness,\n              Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),\n              Buffer.from([0x00, 0x00, 0x00, 0x00]), //Block height\n              Buffer.from([0xff, 0xff, 0xff, 0xff]), //Block index\n              Buffer.from([targetTransaction.inputs[inputIndex].script.length]),\n              targetTransaction.inputs[inputIndex].script\n            ]);\n          });\n\n          result = Buffer.concat([result, decredWitness]);\n        }\n\n        return result.toString(\"hex\");\n      });\n  }\n\n  /**\n   * To obtain the signature of multisignature (P2SH) inputs, call signP2SHTransaction_async with the folowing parameters\n   * @param inputs is an array of [ transaction, output_index, redeem script, optional sequence ] where\n   * * transaction is the previously computed transaction object for this UTXO\n   * * output_index is the output in the transaction used as input for this UTXO (counting from 0)\n   * * redeem script is the mandatory redeem script associated to the current P2SH input\n   * * sequence is the sequence number to use for this input (when using RBF), or non present\n   * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO\n   * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign\n   * @param lockTime is the optional lockTime of the transaction to sign, or default (0)\n   * @param sigHashType is the hash type of the transaction to sign, or default (all)\n   * @return the signed transaction ready to be broadcast\n   * @example\nbtc.signP2SHTransaction(\n [ [tx, 1, \"52210289b4a3ad52a919abd2bdd6920d8a6879b1e788c38aa76f0440a6f32a9f1996d02103a3393b1439d1693b063482c04bd40142db97bdf139eedd1b51ffb7070a37eac321030b9a409a1e476b0d5d17b804fcdb81cf30f9b99c6f3ae1178206e08bc500639853ae\"] ],\n [\"0'/0/0\"],\n \"01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac\"\n).then(result => ...);\n   */\n  signP2SHTransaction(\n    inputs: Array<[Transaction, number, ?string, ?number]>,\n    associatedKeysets: string[],\n    outputScriptHex: string,\n    lockTime?: number = DEFAULT_LOCKTIME,\n    sigHashType?: number = SIGHASH_ALL,\n    segwit?: boolean = false,\n    transactionVersion?: number = DEFAULT_VERSION\n  ) {\n    // Inputs are provided as arrays of [transaction, output_index, redeem script, optional sequence]\n    // associatedKeysets are provided as arrays of [path]\n    const nullScript = Buffer.alloc(0);\n    const nullPrevout = Buffer.alloc(0);\n    const defaultVersion = Buffer.alloc(4);\n    defaultVersion.writeUInt32LE(transactionVersion, 0);\n    const trustedInputs = [];\n    const regularOutputs: Array<TransactionOutput> = [];\n    const signatures = [];\n    let firstRun = true;\n    const resuming = false;\n    let targetTransaction: Transaction = {\n      inputs: [],\n      version: defaultVersion\n    };\n\n    const getTrustedInputCall = segwit\n      ? this.getTrustedInputBIP143.bind(this)\n      : this.getTrustedInput.bind(this);\n    const outputScript = Buffer.from(outputScriptHex, \"hex\");\n\n    return foreach(inputs, input =>\n      doIf(!resuming, () =>\n        getTrustedInputCall(input[1], input[0]).then(trustedInput => {\n          let sequence = Buffer.alloc(4);\n          sequence.writeUInt32LE(\n            input.length >= 4 && typeof input[3] === \"number\"\n              ? input[3]\n              : DEFAULT_SEQUENCE,\n            0\n          );\n          trustedInputs.push({\n            trustedInput: false,\n            value: segwit\n              ? Buffer.from(trustedInput, \"hex\")\n              : Buffer.from(trustedInput, \"hex\").slice(4, 4 + 0x24),\n            sequence\n          });\n        })\n      ).then(() => {\n        const { outputs } = input[0];\n        const index = input[1];\n        if (outputs && index <= outputs.length - 1) {\n          regularOutputs.push(outputs[index]);\n        }\n      })\n    )\n      .then(() => {\n        // Pre-build the target transaction\n        for (let i = 0; i < inputs.length; i++) {\n          let sequence = Buffer.alloc(4);\n          sequence.writeUInt32LE(\n            inputs[i].length >= 4 && typeof inputs[i][3] === \"number\"\n              ? inputs[i][3]\n              : DEFAULT_SEQUENCE,\n            0\n          );\n          targetTransaction.inputs.push({\n            script: nullScript,\n            prevout: nullPrevout,\n            sequence\n          });\n        }\n      })\n      .then(() =>\n        doIf(segwit, () =>\n          // Do the first run with all inputs\n          this.startUntrustedHashTransactionInput(\n            true,\n            targetTransaction,\n            trustedInputs,\n            true\n          ).then(() => this.hashOutputFull(outputScript))\n        )\n      )\n      .then(() =>\n        foreach(inputs, (input, i) => {\n          let script =\n            inputs[i].length >= 3 && typeof inputs[i][2] === \"string\"\n              ? Buffer.from(inputs[i][2], \"hex\")\n              : regularOutputs[i].script;\n          let pseudoTX = Object.assign({}, targetTransaction);\n          let pseudoTrustedInputs = segwit ? [trustedInputs[i]] : trustedInputs;\n          if (segwit) {\n            pseudoTX.inputs = [{ ...pseudoTX.inputs[i], script }];\n          } else {\n            pseudoTX.inputs[i].script = script;\n          }\n          return this.startUntrustedHashTransactionInput(\n            !segwit && firstRun,\n            pseudoTX,\n            pseudoTrustedInputs,\n            segwit\n          )\n            .then(() => doIf(!segwit, () => this.hashOutputFull(outputScript)))\n            .then(() =>\n              this.signTransaction(\n                associatedKeysets[i],\n                lockTime,\n                sigHashType\n              ).then(signature => {\n                signatures.push(\n                  segwit\n                    ? signature.toString(\"hex\")\n                    : signature.slice(0, signature.length - 1).toString(\"hex\")\n                );\n                targetTransaction.inputs[i].script = nullScript;\n                if (firstRun) {\n                  firstRun = false;\n                }\n              })\n            );\n        })\n      )\n      .then(() => signatures);\n  }\n\n  compressPublicKey(publicKey: Buffer): Buffer {\n    const prefix = (publicKey[64] & 1) !== 0 ? 0x03 : 0x02;\n    const prefixBuffer = Buffer.alloc(1);\n    prefixBuffer[0] = prefix;\n    return Buffer.concat([prefixBuffer, publicKey.slice(1, 1 + 32)]);\n  }\n\n  createVarint(value: number): Buffer {\n    if (value < 0xfd) {\n      const buffer = Buffer.alloc(1);\n      buffer[0] = value;\n      return buffer;\n    }\n    if (value <= 0xffff) {\n      const buffer = Buffer.alloc(3);\n      buffer[0] = 0xfd;\n      buffer[1] = value & 0xff;\n      buffer[2] = (value >> 8) & 0xff;\n      return buffer;\n    }\n    const buffer = Buffer.alloc(5);\n    buffer[0] = 0xfe;\n    buffer[1] = value & 0xff;\n    buffer[2] = (value >> 8) & 0xff;\n    buffer[3] = (value >> 16) & 0xff;\n    buffer[4] = (value >> 24) & 0xff;\n    return buffer;\n  }\n\n  /**\n   * For each UTXO included in your transaction, create a transaction object from the raw serialized version of the transaction used in this UTXO.\n   * @example\nconst tx1 = btc.splitTransaction(\"01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000\");\n   */\n  splitTransaction(\n    transactionHex: string,\n    isSegwitSupported: ?boolean = false,\n    hasTimestamp?: boolean = false,\n    hasExtraData?: boolean = false,\n    additionals: Array<string> = []\n  ): Transaction {\n    const inputs = [];\n    const outputs = [];\n    var witness = false;\n    let offset = 0;\n    let timestamp = Buffer.alloc(0);\n    let nExpiryHeight = Buffer.alloc(0);\n    let nVersionGroupId = Buffer.alloc(0);\n    let extraData = Buffer.alloc(0);\n    const isDecred = additionals.includes(\"decred\");\n    const transaction = Buffer.from(transactionHex, \"hex\");\n    const version = transaction.slice(offset, offset + 4);\n    const overwinter =\n      version.equals(Buffer.from([0x03, 0x00, 0x00, 0x80])) ||\n      version.equals(Buffer.from([0x04, 0x00, 0x00, 0x80]));\n    offset += 4;\n    if (\n      !hasTimestamp &&\n      isSegwitSupported &&\n      (transaction[offset] === 0 && transaction[offset + 1] !== 0)\n    ) {\n      offset += 2;\n      witness = true;\n    }\n    if (hasTimestamp) {\n      timestamp = transaction.slice(offset, 4 + offset);\n      offset += 4;\n    }\n    if (overwinter) {\n      nVersionGroupId = transaction.slice(offset, 4 + offset);\n      offset += 4;\n    }\n    let varint = this.getVarint(transaction, offset);\n    const numberInputs = varint[0];\n    offset += varint[1];\n    for (let i = 0; i < numberInputs; i++) {\n      const prevout = transaction.slice(offset, offset + 36);\n      offset += 36;\n      varint = this.getVarint(transaction, offset);\n      offset += varint[1];\n      const script = transaction.slice(offset, offset + varint[0]);\n      offset += varint[0];\n      const sequence = transaction.slice(offset, offset + 4);\n      offset += 4;\n      inputs.push({ prevout, script, sequence });\n    }\n    varint = this.getVarint(transaction, offset);\n    const numberOutputs = varint[0];\n    offset += varint[1];\n    for (let i = 0; i < numberOutputs; i++) {\n      const amount = transaction.slice(offset, offset + 8);\n      offset += 8;\n\n      if (isDecred) {\n        //Script version\n        offset += 2;\n      }\n\n      varint = this.getVarint(transaction, offset);\n      offset += varint[1];\n      const script = transaction.slice(offset, offset + varint[0]);\n      offset += varint[0];\n      outputs.push({ amount, script });\n    }\n    let witnessScript, locktime;\n    if (witness) {\n      witnessScript = transaction.slice(offset, -4);\n      locktime = transaction.slice(transaction.length - 4);\n    } else {\n      locktime = transaction.slice(offset, offset + 4);\n    }\n    offset += 4;\n    if (overwinter || isDecred) {\n      nExpiryHeight = transaction.slice(offset, offset + 4);\n      offset += 4;\n    }\n    if (hasExtraData) {\n      extraData = transaction.slice(offset);\n    }\n\n    return {\n      version,\n      inputs,\n      outputs,\n      locktime,\n      witness: witnessScript,\n      timestamp,\n      nVersionGroupId,\n      nExpiryHeight,\n      extraData\n    };\n  }\n\n  /**\n  @example\nconst tx1 = btc.splitTransaction(\"01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000\");\nconst outputScript = btc.serializeTransactionOutputs(tx1).toString('hex');\n  */\n  serializeTransactionOutputs({ outputs }: Transaction): Buffer {\n    let outputBuffer = Buffer.alloc(0);\n    if (typeof outputs !== \"undefined\") {\n      outputBuffer = Buffer.concat([\n        outputBuffer,\n        this.createVarint(outputs.length)\n      ]);\n      outputs.forEach(output => {\n        outputBuffer = Buffer.concat([\n          outputBuffer,\n          output.amount,\n          this.createVarint(output.script.length),\n          output.script\n        ]);\n      });\n    }\n    return outputBuffer;\n  }\n\n  /**\n   */\n  serializeTransaction(\n    transaction: Transaction,\n    skipWitness: boolean,\n    timestamp?: Buffer,\n    additionals: Array<string> = []\n  ) {\n    const isDecred = additionals.includes(\"decred\");\n    let inputBuffer = Buffer.alloc(0);\n    let useWitness =\n      typeof transaction[\"witness\"] != \"undefined\" && !skipWitness;\n    transaction.inputs.forEach(input => {\n      inputBuffer = isDecred\n        ? Buffer.concat([\n            inputBuffer,\n            input.prevout,\n            Buffer.from([0x00]), //tree\n            input.sequence\n          ])\n        : Buffer.concat([\n            inputBuffer,\n            input.prevout,\n            this.createVarint(input.script.length),\n            input.script,\n            input.sequence\n          ]);\n    });\n\n    let outputBuffer = this.serializeTransactionOutputs(transaction);\n    if (\n      typeof transaction.outputs !== \"undefined\" &&\n      typeof transaction.locktime !== \"undefined\"\n    ) {\n      outputBuffer = Buffer.concat([\n        outputBuffer,\n        (useWitness && transaction.witness) || Buffer.alloc(0),\n        transaction.locktime,\n        transaction.nExpiryHeight || Buffer.alloc(0),\n        transaction.extraData || Buffer.alloc(0)\n      ]);\n    }\n\n    return Buffer.concat([\n      transaction.version,\n      timestamp ? timestamp : Buffer.alloc(0),\n      transaction.nVersionGroupId || Buffer.alloc(0),\n      useWitness ? Buffer.from(\"0001\", \"hex\") : Buffer.alloc(0),\n      this.createVarint(transaction.inputs.length),\n      inputBuffer,\n      outputBuffer\n    ]);\n  }\n\n  /**\n   */\n  displayTransactionDebug(transaction: Transaction) {\n    console.log(\"version \" + transaction.version.toString(\"hex\"));\n    transaction.inputs.forEach((input, i) => {\n      const prevout = input.prevout.toString(\"hex\");\n      const script = input.script.toString(\"hex\");\n      const sequence = input.sequence.toString(\"hex\");\n      console.log(\n        `input ${i} prevout ${prevout} script ${script} sequence ${sequence}`\n      );\n    });\n    (transaction.outputs || []).forEach((output, i) => {\n      const amount = output.amount.toString(\"hex\");\n      const script = output.script.toString(\"hex\");\n      console.log(`output ${i} amount ${amount} script ${script}`);\n    });\n    if (typeof transaction.locktime !== \"undefined\") {\n      console.log(\"locktime \" + transaction.locktime.toString(\"hex\"));\n    }\n  }\n}\n\n/**\n */\ntype TransactionInput = {\n  prevout: Buffer,\n  script: Buffer,\n  sequence: Buffer\n};\n\n/**\n */\ntype TransactionOutput = {\n  amount: Buffer,\n  script: Buffer\n};\n\n/**\n */\ntype Transaction = {\n  version: Buffer,\n  inputs: TransactionInput[],\n  outputs?: TransactionOutput[],\n  locktime?: Buffer,\n  witness?: Buffer,\n  timestamp?: Buffer,\n  nVersionGroupId?: Buffer,\n  nExpiryHeight?: Buffer,\n  extraData?: Buffer\n};\n"]}